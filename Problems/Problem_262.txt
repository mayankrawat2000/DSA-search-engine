You are given a tree consisting of nn vertices (numbered from 11 to nn) and n−1n−1 edges (numbered from 11 to n−1n−1). Initially, all vertices except vertex 11 are inactive.
You have to process queries of three types:
  11 vv — activate the vertex vv. It is guaranteed that the vertex vv is inactive before this query, and one of its neighbors is active. After activating the vertex, you have to choose a subset of edges of the tree such that each active vertex is incident to exactly one chosen edge, and each inactive vertex is not incident to any of the chosen edges — in other words, this subset should represent a perfect matching on the active part of the tree. If any such subset of edges exists, print the sum of indices of edges in it; otherwise, print 00.  22 — queries of this type will be asked only right after a query of type 11, and there will be at most 1010 such queries. If your answer to the previous query was 00, simply print 00; otherwise, print the subset of edges for the previous query as follows: first, print the number of edges in the subset, then print the indices of the chosen edges in ascending order. The sum of indices should be equal to your answer to the previous query.  33 — terminate the program. 
Note that you should solve the problem in online mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query. Use functions fflush in C++ and BufferedWriter.flush in Java languages after each writing in your program.
