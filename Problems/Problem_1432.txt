You've got a string SS consisting of nn lowercase English letters from your friend. It turned out that this is a number written in poman numerals. The poman numeral system is long forgotten. All that's left is the algorithm to transform number from poman numerals to the numeral system familiar to us. Characters of SS are numbered from 11 to nn from left to right. Let's denote the value of SS as f(S)f(S), it is defined as follows: 
  If |S|>1|S|>1, an arbitrary integer mm (1≤m<|S|1≤m<|S|) is chosen, and it is defined that f(S)=−f(S[1,m])+f(S[m+1,|S|])f(S)=−f(S[1,m])+f(S[m+1,|S|]), where S[l,r]S[l,r] denotes the substring of SS from the ll-th to the rr-th position, inclusively.  Otherwise S=cS=c, where cc is some English letter. Then f(S)=2pos(c)f(S)=2pos(c), where pos(c)pos(c) is the position of letter cc in the alphabet (pos(pos(a)=0)=0, pos(pos(z)=25)=25). 
Note that mm is chosen independently on each step.
Your friend thinks it is possible to get f(S)=Tf(S)=T by choosing the right mm on every step. Is he right?
