This is the easy version of the problem. The only difference between the two versions is that the harder version asks additionally for a minimum number of subsegments.
Tokitsukaze has a binary string ss of length nn, consisting only of zeros and ones, nn is even.
Now Tokitsukaze divides ss into the minimum number of contiguous subsegments, and for each subsegment, all bits in each subsegment are the same. After that, ss is considered good if the lengths of all subsegments are even.
For example, if ss is "11001111", it will be divided into "11", "00" and "1111". Their lengths are 22, 22, 44 respectively, which are all even numbers, so "11001111" is good. Another example, if ss is "1110011000", it will be divided into "111", "00", "11" and "000", and their lengths are 33, 22, 22, 33. Obviously, "1110011000" is not good.
Tokitsukaze wants to make ss good by changing the values of some positions in ss. Specifically, she can perform the operation any number of times: change the value of sisi to '0' or '1'(1≤i≤n1≤i≤n). Can you tell her the minimum number of operations to make ss good?
