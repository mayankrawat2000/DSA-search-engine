This is an unusual problem in an unusual contest, here is the announcement: http://codeforces.com/blog/entry/73543
Andrey has just started to study competitive programming and he is fascinated by bitsets and operations on them.
For example, assume he has a bitset with nn elements. He can change the values of the bitset in the following way: 
  He chooses different indices i0i0, i1i1, i2i2, ... ikik (k≥1k≥1, 1≤ij≤n1≤ij≤n) so that bit i0i0 is different from all bits i1i1, i2i2, ... ikik.  He flips all these k+1k+1 bits. 
 
He calls a bitset amazing if he can flip all the bits using several such changes.
Another topic Andrey is interested in is probability theory. For given nn and pp, where pp is a rational number represented as abab with integer a,ba,b, he considers all bitsets of length nn, where each element is equal to 11 with probability pp independently of the other elements.
He wants to know the probability that a bitset generated by the described method is amazing.
It is guaranteed that the answer to this problem can be represented as a rational number xyxy, where yy is coprime with 12345678911234567891. You need to output such integer zz that x≡yz(mod1234567891)x≡yz(mod1234567891) and 0≤z<12345678910≤z<1234567891.
